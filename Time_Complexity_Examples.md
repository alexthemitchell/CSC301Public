* O(n)
  * Counting Algorithm
  * Just made it up in my head
  * An algorithm which counts a finite number of elements in a set or array is O(n), as it must "touch" every element in the dataset.
* O(log n)
  * Binary Search
  * https://en.wikipedia.org/wiki/Binary_search_algorithm
  * The optimal search algorithm has a time complexity of log(base 2) of the number of elements to iterate through. This may only be used when the elements are in some defined order. Since each time the set to search becomes half as large, the total search time is log(n) in the worst case 
* O(n log n)
  * Quicksort (Best/Average)
  * https://en.wikipedia.org/wiki/Quicksort
  * The optimal sort algorithm parallelizes the sorting of a dataset by recursively sorting subsets consisting of half the remaining elements.
* O(n^c)   e.g   c = 2, c = 3 
  * Selection Sort
  * https://en.wikipedia.org/wiki/Selection_sort
  * This algorithm iterates through the entire remaining dataset to find the next element in sequence.
* O(c^n)   e.g   c = 2, c = 3
  * Held-Karp algorithm
  * https://en.wikipedia.org/wiki/Held%E2%80%93Karp_algorithm
  * "Every subpath of a path of minimum distance is itself of minimum distance."
* O(n!)
  * Solving the Travelling salesman problem using brute force search
  * https://en.wikipedia.org/wiki/Travelling_salesman_problem
  * Testing every set of two cities and checking for least expensive route "becomes impractical even for only 20 cities."

